'use client';
'use client';
import { useEffect } from "react";
import { useRouter } from "next/router";
import { useRouter as useRouter$1 } from "next/navigation";
import { getPrismicPreviewCookie } from "./lib/getPrismicPreviewCookie.js";
import { getPreviewCookieRepositoryName } from "./lib/getPreviewCookieRepositoryName.js";
function PrismicPreviewClient({ repositoryName, updatePreviewURL = "/api/preview", exitPreviewURL = "/api/exit-preview", isDraftMode }) {
  let isPreviewActive = isDraftMode;
  let isAppRouter = true;
  let basePath = "";
  let refresh;
  try {
    const router = useRouter();
    isAppRouter = false;
    basePath = router.basePath;
    isPreviewActive || (isPreviewActive = router.isPreview);
    refresh = () => router.replace(router.asPath, void 0, { scroll: false });
  } catch {
    const router = useRouter$1();
    refresh = router.refresh;
  }
  useEffect(() => {
    const startPreviewMode = async () => {
      const resolvedUpdatePreviewURL = basePath + updatePreviewURL;
      const res = await globalThis.fetch(resolvedUpdatePreviewURL);
      if (res.redirected) {
        refresh();
      } else {
        console.error(`[<PrismicPreview>] Failed to start or update Preview Mode using the "${resolvedUpdatePreviewURL}" API endpoint. Does it exist?`);
      }
    };
    const handlePrismicPreviewUpdate = async (event) => {
      event.preventDefault();
      if (isAppRouter) {
        refresh();
      } else {
        await startPreviewMode();
      }
    };
    const handlePrismicPreviewEnd = async (event) => {
      event.preventDefault();
      const resolvedExitPreviewURL = basePath + exitPreviewURL;
      const res = await globalThis.fetch(resolvedExitPreviewURL);
      if (res.ok) {
        refresh();
      } else {
        console.error(`[<PrismicPreview>] Failed to exit Preview Mode using the "${resolvedExitPreviewURL}" API endpoint. Does it exist?`);
      }
    };
    window.addEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
    window.addEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
    if (!isPreviewActive) {
      const prismicPreviewCookie = getPrismicPreviewCookie(globalThis.document.cookie);
      if (prismicPreviewCookie) {
        const locationIsDescendantOfBasePath = window.location.href.startsWith(window.location.origin + basePath);
        const prismicPreviewCookieRepositoryName = getPreviewCookieRepositoryName(prismicPreviewCookie);
        if (locationIsDescendantOfBasePath && prismicPreviewCookieRepositoryName === repositoryName) {
          startPreviewMode();
        }
      }
    }
    return () => {
      window.removeEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
      window.removeEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
    };
  }, [
    basePath,
    exitPreviewURL,
    isAppRouter,
    isPreviewActive,
    refresh,
    repositoryName,
    updatePreviewURL
  ]);
  return null;
}
export {
  PrismicPreviewClient
};
//# sourceMappingURL=PrismicPreviewClient.js.map
