{"version":3,"file":"PrismicPreviewClient.js","sources":["../../src/PrismicPreviewClient.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useRouter as usePagesRouter } from \"next/router\";\nimport { useRouter } from \"next/navigation\";\n\nimport { getPrismicPreviewCookie } from \"./lib/getPrismicPreviewCookie\";\nimport { getPreviewCookieRepositoryName } from \"./lib/getPreviewCookieRepositoryName\";\n\nimport { PrismicPreviewProps } from \"./PrismicPreview\";\n\ntype PrismicPreviewClientProps = Omit<PrismicPreviewProps, \"children\"> & {\n\tisDraftMode: boolean;\n};\n\nexport function PrismicPreviewClient({\n\trepositoryName,\n\tupdatePreviewURL = \"/api/preview\",\n\texitPreviewURL = \"/api/exit-preview\",\n\tisDraftMode,\n}: PrismicPreviewClientProps): null {\n\tlet isPreviewActive = isDraftMode;\n\tlet isAppRouter = true;\n\tlet basePath = \"\";\n\tlet refresh: () => void;\n\n\ttry {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst router = usePagesRouter();\n\n\t\tisAppRouter = false;\n\t\tbasePath = router.basePath;\n\t\tisPreviewActive ||= router.isPreview;\n\t\trefresh = () => router.replace(router.asPath, undefined, { scroll: false });\n\t} catch {\n\t\t// Assume we are in App Router. Ignore the error.\n\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst router = useRouter();\n\n\t\trefresh = router.refresh;\n\t}\n\n\tuseEffect(() => {\n\t\t/**\n\t\t * Starts Preview Mode and refreshes the page's props.\n\t\t */\n\t\tconst startPreviewMode = async () => {\n\t\t\tconst resolvedUpdatePreviewURL = basePath + updatePreviewURL;\n\n\t\t\t// Start Next.js Preview Mode via the given preview API endpoint.\n\t\t\tconst res = await globalThis.fetch(resolvedUpdatePreviewURL);\n\n\t\t\t// We check for `res.redirected` rather than `res.ok`\n\t\t\t// since the update preview endpoint may redirect to a\n\t\t\t// 404 page. As long as it redirects, we know the\n\t\t\t// endpoint exists and at least attempted to set\n\t\t\t// preview data.\n\t\t\tif (res.redirected) {\n\t\t\t\trefresh();\n\t\t\t} else {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`[<PrismicPreview>] Failed to start or update Preview Mode using the \"${resolvedUpdatePreviewURL}\" API endpoint. Does it exist?`,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\tconst handlePrismicPreviewUpdate = async (event: Event) => {\n\t\t\t// Prevent the toolbar from reloading the page.\n\t\t\tevent.preventDefault();\n\n\t\t\tif (isAppRouter) {\n\t\t\t\trefresh();\n\t\t\t} else {\n\t\t\t\tawait startPreviewMode();\n\t\t\t}\n\t\t};\n\n\t\tconst handlePrismicPreviewEnd = async (event: Event) => {\n\t\t\t// Prevent the toolbar from reloading the page.\n\t\t\tevent.preventDefault();\n\n\t\t\tconst resolvedExitPreviewURL = basePath + exitPreviewURL;\n\n\t\t\t// Exit Next.js Preview Mode via the given preview API endpoint.\n\t\t\tconst res = await globalThis.fetch(resolvedExitPreviewURL);\n\n\t\t\tif (res.ok) {\n\t\t\t\trefresh();\n\t\t\t} else {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`[<PrismicPreview>] Failed to exit Preview Mode using the \"${resolvedExitPreviewURL}\" API endpoint. Does it exist?`,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"prismicPreviewUpdate\", handlePrismicPreviewUpdate);\n\t\twindow.addEventListener(\"prismicPreviewEnd\", handlePrismicPreviewEnd);\n\n\t\tif (!isPreviewActive) {\n\t\t\tconst prismicPreviewCookie = getPrismicPreviewCookie(\n\t\t\t\tglobalThis.document.cookie,\n\t\t\t);\n\n\t\t\tif (prismicPreviewCookie) {\n\t\t\t\t// If a Prismic preview cookie is present, but Next.js Preview\n\t\t\t\t// Mode is not active, we must activate Preview Mode manually.\n\t\t\t\t//\n\t\t\t\t// This will happen when a visitor accesses the page using a\n\t\t\t\t// Prismic preview share link.\n\n\t\t\t\t/**\n\t\t\t\t * Determines if the current location is a descendant of the app's base\n\t\t\t\t * path.\n\t\t\t\t *\n\t\t\t\t * This is used to prevent infinite refrehes; when\n\t\t\t\t * `isDescendantOfBasePath` is `false`, `router.isPreview` is also\n\t\t\t\t * `false`.\n\t\t\t\t *\n\t\t\t\t * If the app does not have a base path, this should always be `true`.\n\t\t\t\t */\n\t\t\t\tconst locationIsDescendantOfBasePath = window.location.href.startsWith(\n\t\t\t\t\twindow.location.origin + basePath,\n\t\t\t\t);\n\n\t\t\t\tconst prismicPreviewCookieRepositoryName =\n\t\t\t\t\tgetPreviewCookieRepositoryName(prismicPreviewCookie);\n\n\t\t\t\tif (\n\t\t\t\t\tlocationIsDescendantOfBasePath &&\n\t\t\t\t\tprismicPreviewCookieRepositoryName === repositoryName\n\t\t\t\t) {\n\t\t\t\t\tstartPreviewMode();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\n\t\t\t\t\"prismicPreviewUpdate\",\n\t\t\t\thandlePrismicPreviewUpdate,\n\t\t\t);\n\t\t\twindow.removeEventListener(\"prismicPreviewEnd\", handlePrismicPreviewEnd);\n\t\t};\n\t}, [\n\t\tbasePath,\n\t\texitPreviewURL,\n\t\tisAppRouter,\n\t\tisPreviewActive,\n\t\trefresh,\n\t\trepositoryName,\n\t\tupdatePreviewURL,\n\t]);\n\n\treturn null;\n}\n"],"names":[],"mappings":";;;;;;;AAegB;AAMf;AACA;AACA;AACI;AAEA;AAEH;AAEc;AACd;AACA;AACU;AAAgE;AAK1E;AAEA;AAAiB;AAGlB;AAIC;AACC;AAGA;AAOA;;;AAGS;AACyH;AAEjI;AAGI;AAEL;AAEA;;;AAGC;;AACA;AAGI;AAEL;AAEA;AAGA;AAEA;;;AAGS;AAC4G;AAEpH;AAGK;AACA;AAEP;AACC;AAIA;AAiBO;AAIA;AAIL;;;AAIA;AACD;AAGF;AACQ;AAIA;AAAgE;AAAA;AAEtE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AAGM;AACR;;;;"}