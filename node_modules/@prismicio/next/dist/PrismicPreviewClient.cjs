'use client';
'use client';
"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
const router = require("next/router");
const navigation = require("next/navigation");
const getPrismicPreviewCookie = require("./lib/getPrismicPreviewCookie.cjs");
const getPreviewCookieRepositoryName = require("./lib/getPreviewCookieRepositoryName.cjs");
function PrismicPreviewClient({ repositoryName, updatePreviewURL = "/api/preview", exitPreviewURL = "/api/exit-preview", isDraftMode }) {
  let isPreviewActive = isDraftMode;
  let isAppRouter = true;
  let basePath = "";
  let refresh;
  try {
    const router$1 = router.useRouter();
    isAppRouter = false;
    basePath = router$1.basePath;
    isPreviewActive || (isPreviewActive = router$1.isPreview);
    refresh = () => router$1.replace(router$1.asPath, void 0, { scroll: false });
  } catch {
    const router2 = navigation.useRouter();
    refresh = router2.refresh;
  }
  React.useEffect(() => {
    const startPreviewMode = async () => {
      const resolvedUpdatePreviewURL = basePath + updatePreviewURL;
      const res = await globalThis.fetch(resolvedUpdatePreviewURL);
      if (res.redirected) {
        refresh();
      } else {
        console.error(`[<PrismicPreview>] Failed to start or update Preview Mode using the "${resolvedUpdatePreviewURL}" API endpoint. Does it exist?`);
      }
    };
    const handlePrismicPreviewUpdate = async (event) => {
      event.preventDefault();
      if (isAppRouter) {
        refresh();
      } else {
        await startPreviewMode();
      }
    };
    const handlePrismicPreviewEnd = async (event) => {
      event.preventDefault();
      const resolvedExitPreviewURL = basePath + exitPreviewURL;
      const res = await globalThis.fetch(resolvedExitPreviewURL);
      if (res.ok) {
        refresh();
      } else {
        console.error(`[<PrismicPreview>] Failed to exit Preview Mode using the "${resolvedExitPreviewURL}" API endpoint. Does it exist?`);
      }
    };
    window.addEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
    window.addEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
    if (!isPreviewActive) {
      const prismicPreviewCookie = getPrismicPreviewCookie.getPrismicPreviewCookie(globalThis.document.cookie);
      if (prismicPreviewCookie) {
        const locationIsDescendantOfBasePath = window.location.href.startsWith(window.location.origin + basePath);
        const prismicPreviewCookieRepositoryName = getPreviewCookieRepositoryName.getPreviewCookieRepositoryName(prismicPreviewCookie);
        if (locationIsDescendantOfBasePath && prismicPreviewCookieRepositoryName === repositoryName) {
          startPreviewMode();
        }
      }
    }
    return () => {
      window.removeEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
      window.removeEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
    };
  }, [
    basePath,
    exitPreviewURL,
    isAppRouter,
    isPreviewActive,
    refresh,
    repositoryName,
    updatePreviewURL
  ]);
  return null;
}
exports.PrismicPreviewClient = PrismicPreviewClient;
//# sourceMappingURL=PrismicPreviewClient.cjs.map
