"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const commonTags = require("common-tags");
const fs = require("node:fs/promises");
const path = require("node:path");
const buildSliceDirectoryPath = require("../lib/buildSliceDirectoryPath.cjs");
const checkIsTypeScriptProject = require("../lib/checkIsTypeScriptProject.cjs");
const getJSFileExtension = require("../lib/getJSFileExtension.cjs");
const pascalCase = require("../lib/pascalCase.cjs");
const rejectIfNecessary = require("../lib/rejectIfNecessary.cjs");
const updateSliceModelFile = require("../lib/updateSliceModelFile.cjs");
const upsertGlobalContentTypes = require("../lib/upsertGlobalContentTypes.cjs");
const upsertSliceLibraryIndexFile = require("../lib/upsertSliceLibraryIndexFile.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const createComponentFile = async ({ dir, data, helpers, options }) => {
  const extension = await getJSFileExtension.getJSFileExtension({ helpers, options, jsx: true });
  const filePath = path__namespace.join(dir, `index.${extension}`);
  const model = data.model;
  const pascalName = pascalCase.pascalCase(model.name);
  let contents;
  const isTypeScriptProject = await checkIsTypeScriptProject.checkIsTypeScriptProject({
    helpers,
    options
  });
  if (isTypeScriptProject) {
    contents = commonTags.stripIndent`
			import { Content } from "@prismicio/client";
			import { SliceComponentProps } from "@prismicio/react";

			/**
			 * Props for \`${pascalName}\`.
			 */
			export type ${pascalName}Props = SliceComponentProps<Content.${pascalName}Slice>;

			/**
			 * Component for "${model.name}" Slices.
			 */
			const ${pascalName} = ({ slice }: ${pascalName}Props): JSX.Element => {
				return (
					<section
						data-slice-type={slice.slice_type}
						data-slice-variation={slice.variation}
					>
						Placeholder component for ${model.id} (variation: {slice.variation}) Slices
					</section>
				);
			};

			export default ${pascalName}
		`;
  } else {
    contents = commonTags.stripIndent`
			/**
			 * @typedef {import("@prismicio/client").Content.${pascalName}Slice} ${pascalName}Slice
			 * @typedef {import("@prismicio/react").SliceComponentProps<${pascalName}Slice>} ${pascalName}Props
			 * @param {${pascalName}Props}
			 */
			const ${pascalName} = ({ slice }) => {
				return (
					<section
						data-slice-type={slice.slice_type}
						data-slice-variation={slice.variation}
					>
						Placeholder component for ${model.id} (variation: {slice.variation}) Slices
					</section>
				);
			};

			export default ${pascalName};
		`;
  }
  if (options.format) {
    contents = await helpers.format(contents, filePath);
  }
  await fs__namespace.writeFile(filePath, contents);
};
const sliceCreate = async (data, context) => {
  const dir = buildSliceDirectoryPath.buildSliceDirectoryPath({
    libraryID: data.libraryID,
    model: data.model,
    helpers: context.helpers
  });
  await fs__namespace.mkdir(dir, { recursive: true });
  rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
    updateSliceModelFile.updateSliceModelFile({
      libraryID: data.libraryID,
      model: data.model,
      ...context
    }),
    createComponentFile({ dir, data, ...context })
  ]));
  rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
    upsertGlobalContentTypes.upsertGlobalContentTypes(context),
    upsertSliceLibraryIndexFile.upsertSliceLibraryIndexFile({ libraryID: data.libraryID, ...context })
  ]));
};
exports.sliceCreate = sliceCreate;
//# sourceMappingURL=slice-create.cjs.map
